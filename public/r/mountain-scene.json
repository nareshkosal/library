{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "mountain-scene",
  "type": "registry:block",
  "title": "Mountain Scene",
  "description": "A 3D mountain scene with dynamic lighting, ocean, and clouds using React Three Fiber.",
  "dependencies": [
    "@react-three/fiber",
    "@react-three/drei",
    "three"
  ],
  "files": [
    {
      "path": "registry/new-york/blocks/MountainScene/MountainScene.tsx",
      "content": "'use client';\n\nimport { useEffect, useMemo, useState } from 'react';\nimport { Canvas } from '@react-three/fiber';\nimport { useGLTF, Preload, OrbitControls } from '@react-three/drei';\nimport { Ocean } from './Ocean';\nimport { MountainLake } from './MountainLake';\nimport { DynamicLighting } from './DynamicLighting';\nimport { NightClouds } from './NightClouds';\nimport { HorizonBackground } from './HorizonBackground';\nimport { useSearchParams } from 'next/navigation';\nimport { StarField } from './StarField';\n\ninterface BoatControls {\n  forward: boolean;\n  backward: boolean;\n  left: boolean;\n  right: boolean;\n}\n\n// Preload GLTF models\nuseGLTF.preload('/boat1.glb');\nuseGLTF.preload('/frozen_lake.glb');\n\nexport default function MountainScene() {\n  const [] = useState<BoatControls>({\n    forward: false,\n    backward: false,\n    left: false,\n    right: false,\n  });\n  const search = useSearchParams();\n  const initialTheme = useMemo(() => {\n    const t = search?.get('theme');\n    return t === 'sunset' ? 'sunset' : 'night';\n  }, [search]);\n  const [theme, setTheme] = useState<'night' | 'sunset'>(initialTheme);\n\n  useEffect(() => {\n    const onKey = (e: KeyboardEvent) => {\n      if (e.key.toLowerCase() === 's') setTheme('sunset');\n      if (e.key.toLowerCase() === 'n') setTheme('night');\n    };\n    window.addEventListener('keydown', onKey);\n    return () => window.removeEventListener('keydown', onKey);\n  }, []);\n\n  return (\n    <Canvas shadows camera={{ position: [-150, 20, 500], fov: 80, near: 0.1, far: 12000 }}>\n      <ambientLight intensity={0.05} />\n      <DynamicLighting />\n      {theme === 'sunset' ? (\n        <HorizonBackground variant=\"sunset\" intensity={1.05} horizonBand={0.5} />\n      ) : (\n        <HorizonBackground variant=\"night\" intensity={1} horizonBand={0.5} />\n      )}\n      <Ocean transitionProgress={theme === 'sunset' ? 0.7 : 1.0} />\n      <MountainLake />\n      {theme === 'night' && <NightClouds />}\n      {theme === 'night' && <StarField />}\n      <OrbitControls enableDamping dampingFactor={0.05} enableRotate={false} maxDistance={1500} minDistance={80} />\n      <Preload all />\n    </Canvas>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/mountain-scene/mountain-scene.tsx"
    },
    {
      "path": "registry/new-york/blocks/MountainScene/Ocean.tsx",
      "content": "import * as THREE from 'three';\nimport { useRef, useEffect } from 'react';\nimport { useThree, useFrame } from '@react-three/fiber';\nimport { Water } from 'three-stdlib';\nimport { Water as WaterImpl } from 'three-stdlib';\n\nconst dayWaterColor = new THREE.Color(0x001e0f);\nconst nightWaterColor = new THREE.Color(0x1a2852);\n\ninterface OceanProps {\n  transitionProgress: number;\n}\n\nexport function Ocean({ transitionProgress }: OceanProps) {\n  const ref = useRef<WaterImpl>(null);\n  const { scene } = useThree();\n\n  useEffect(() => {\n    const waterGeometry = new THREE.PlaneGeometry(100000, 100000);\n\n    const waterNormals = new THREE.TextureLoader().load(\n      'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/waternormals.jpg',\n      (texture) => {\n        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;\n      }\n    );\n\n    const water = new Water(waterGeometry, {\n      textureWidth: 512,\n      textureHeight: 512,\n      waterNormals,\n      sunDirection: new THREE.Vector3(),\n      sunColor: 0xffffff,\n      waterColor: dayWaterColor,\n      distortionScale: 3.7,\n      fog: true,\n    });\n\n    water.rotation.x = -Math.PI / 2;\n    scene.add(water);\n    ref.current = water;\n\n    return () => {\n      scene.remove(water);\n    };\n  }, [scene]);\n\n  useFrame((_, delta) => {\n    if (ref.current) {\n      const material = ref.current.material as THREE.ShaderMaterial;\n      material.uniforms['time'].value += delta / 2;\n\n      const waterColor = dayWaterColor.clone().lerp(nightWaterColor, transitionProgress);\n      material.uniforms['waterColor'].value = waterColor;\n    }\n\n    scene.background = getSkyColorForTransition(transitionProgress);\n  });\n\n  function getSkyColorForTransition(t: number) {\n    const daySkyColor = new THREE.Color(0x87ceeb);\n    const nightSkyColor = new THREE.Color(0x000011);\n    return daySkyColor.clone().lerp(nightSkyColor, t);\n  }\n\n  return null;\n}",
      "type": "registry:component",
      "target": "components/mountain-scene/ocean.tsx"
    },
    {
      "path": "registry/new-york/blocks/MountainScene/MountainLake.tsx",
      "content": "import * as THREE from 'three';\nimport { useRef, useEffect } from 'react';\nimport { useGLTF } from '@react-three/drei';\n\nexport function MountainLake() {\n  const { scene } = useGLTF('/frozen_lake.glb');\n  const ref = useRef<THREE.Group>(null);\n\n  useEffect(() => {\n    scene.traverse((child) => {\n      if ((child as THREE.Mesh).isMesh) {\n        const mesh = child as THREE.Mesh;\n        mesh.castShadow = true;\n        mesh.receiveShadow = true;\n        // Preserve original material colors\n        if (mesh.material) {\n          const material = mesh.material as THREE.MeshStandardMaterial;\n          if (material.color) {\n            // Ensure the material displays its original colors\n            material.color.multiplyScalar(1.2); // Slightly brighten original colors\n          }\n        }\n      }\n    });\n  }, [scene]);\n\n  return (\n    <group ref={ref}>\n      <primitive object={scene} scale={1780} position={[0, -350.2, 200]} />\n      {/* Dedicated lighting for the mountain to show original colors */}\n      <directionalLight\n        position={[0, 100, 200]}\n        intensity={0.8}\n        color=\"#ffffff\"\n      />\n      <pointLight\n        position={[100, 50, 100]}\n        intensity={0.5}\n        color=\"#ffffff\"\n        distance={1000}\n      />\n    </group>\n  );\n}",
      "type": "registry:component",
      "target": "components/mountain-scene/mountain-lake.tsx"
    },
    {
      "path": "registry/new-york/blocks/MountainScene/DynamicLighting.tsx",
      "content": "import * as THREE from 'three';\nimport { useRef } from 'react';\nimport { useFrame } from '@react-three/fiber';\n\nexport function DynamicLighting() {\n  const lightRef = useRef<THREE.DirectionalLight>(null);\n  const time = useRef(0);\n\n  useFrame((state, delta) => {\n    if (lightRef.current) {\n      time.current += delta * 0.2;\n      \n      // Subtle moonlight intensity changes\n      const intensity = 0.2 + Math.sin(time.current * 0.3) * 0.05;\n      lightRef.current.intensity = intensity;\n      \n      // Subtle position changes for dynamic shadows\n      const x = Math.sin(time.current * 0.1) * 20;\n      const z = 100 + Math.cos(time.current * 0.15) * 30;\n      lightRef.current.position.set(x, 50, z);\n    }\n  });\n\n  return (\n    <>\n      <directionalLight\n        ref={lightRef}\n        position={[0, 50, 100]}\n        intensity={0.15}\n        color=\"#cccccc\"\n        castShadow\n        shadow-mapSize-width={2048}\n        shadow-mapSize-height={2048}\n        shadow-camera-far={1000}\n        shadow-camera-left={-500}\n        shadow-camera-right={500}\n        shadow-camera-top={500}\n        shadow-camera-bottom={-500}\n      />\n      <directionalLight\n        position={[100, 30, -50]}\n        intensity={0.1}\n        color=\"#dddddd\"\n      />\n    </>\n  );\n}",
      "type": "registry:component",
      "target": "components/mountain-scene/dynamic-lighting.tsx"
    },
    {
      "path": "registry/new-york/blocks/MountainScene/AnimatedCloud.tsx",
      "content": "import * as THREE from 'three';\nimport { useRef, forwardRef, useImperativeHandle } from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport { Cloud } from '@react-three/drei';\n\ninterface AnimatedCloudProps {\n  position: [number, number, number];\n  scale: [number, number, number];\n  speed: number;\n  opacity: number;\n  radius?: number;\n  height?: number;\n  color?: string;\n  editable?: boolean;\n}\n\nexport const AnimatedCloud = forwardRef<THREE.Group, AnimatedCloudProps>(function AnimatedCloud({ position, scale, speed, opacity, radius = 200, height = 0, color, editable }, ref) {\n  const cloudRef = useRef<THREE.Group>(null);\n  const time = useRef(0);\n  useImperativeHandle(ref, () => cloudRef.current as THREE.Group);\n\n  useFrame((state, delta) => {\n    if (!cloudRef.current) return;\n    if (editable) return;\n    time.current += delta * speed;\n    const x = position[0] + Math.sin(time.current * 0.3) * radius;\n    const z = position[2] + Math.cos(time.current * 0.2) * radius * 0.7;\n    const y = position[1] + Math.sin(time.current * 0.1) * height;\n    cloudRef.current.position.set(x, y, z);\n    cloudRef.current.rotation.y = time.current * 0.05;\n    const scaleVariation = 1 + Math.sin(time.current * 0.8) * 0.05;\n    cloudRef.current.scale.set(\n      scale[0] * scaleVariation,\n      scale[1] * scaleVariation,\n      scale[2] * scaleVariation\n    );\n  });\n\n  return (\n    <group ref={cloudRef}>\n      <Cloud\n        position={[0, 0, 0]}\n        speed={speed * 0.5}\n        opacity={opacity}\n        color={color}\n      />\n    </group>\n  );\n});\n",
      "type": "registry:component",
      "target": "components/mountain-scene/animated-cloud.tsx"
    },
    {
      "path": "registry/new-york/blocks/MountainScene/StarField.tsx",
      "content": "import * as THREE from 'three';\nimport { useMemo, useRef } from 'react';\nimport { useFrame } from '@react-three/fiber';\n\nexport function StarField() {\n  const groupRef = useRef<THREE.Group>(null);\n\n  const { small, medium, large } = useMemo(() => {\n    const maxRadius = 4000;\n    const counts = { small: 1000, medium: 100, large: 40 };\n    const radii = { small: maxRadius, medium: maxRadius * 0.9, large: maxRadius * 0.8 };\n\n    const makeLayer = (count: number, radius: number) => {\n      const positions = new Float32Array(count * 3);\n      const rMin = radius * 0.6;\n      const rMax = radius;\n      for (let i = 0; i < count; i++) {\n        const u = Math.random();\n        const r = Math.cbrt(rMin * rMin * rMin + (rMax * rMax * rMax - rMin * rMin * rMin) * u);\n        const phi = Math.random() * 2 * Math.PI;\n        const cosTheta = Math.random();\n        const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);\n        const x = r * sinTheta * Math.cos(phi);\n        const y = r * cosTheta;\n        const z = r * sinTheta * Math.sin(phi);\n        const idx = i * 3;\n        positions[idx] = x;\n        positions[idx + 1] = y;\n        positions[idx + 2] = z;\n      }\n      return positions;\n    };\n\n    return {\n      small: makeLayer(counts.small, radii.small),\n      medium: makeLayer(counts.medium, radii.medium),\n      large: makeLayer(counts.large, radii.large),\n    };\n  }, []);\n\n  useFrame((_, delta) => {\n    if (groupRef.current) {\n      groupRef.current.rotation.y += delta * 0.004;\n    }\n  });\n\n  return (\n    <group ref={groupRef}>\n      <points frustumCulled={false}>\n        <bufferGeometry>\n          <bufferAttribute attach=\"attributes-position\" args={[small, 3]} />\n        </bufferGeometry>\n        <pointsMaterial color={0xffffff} size={0.9} sizeAttenuation transparent opacity={0.9} depthWrite={false} blending={THREE.AdditiveBlending} />\n      </points>\n      <points frustumCulled={false}>\n        <bufferGeometry>\n          <bufferAttribute attach=\"attributes-position\" args={[medium, 3]} />\n        </bufferGeometry>\n        <pointsMaterial color={0xffffff} size={1.4} sizeAttenuation transparent opacity={0.95} depthWrite={false} blending={THREE.AdditiveBlending} />\n      </points>\n      <points frustumCulled={false}>\n        <bufferGeometry>\n          <bufferAttribute attach=\"attributes-position\" args={[large, 3]} />\n        </bufferGeometry>\n        <pointsMaterial color={0xffffff} size={2.0} sizeAttenuation transparent opacity={1} depthWrite={false} blending={THREE.AdditiveBlending} />\n      </points>\n    </group>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/mountain-scene/star-field.tsx"
    },
    {
      "path": "registry/new-york/blocks/MountainScene/NightClouds.tsx",
      "content": "import { Cloud } from '@react-three/drei';\nimport { AnimatedCloud } from './AnimatedCloud';\n\nexport function NightClouds() {\n  return (\n    <>\n      <AnimatedCloud position={[480, 300, -400]} scale={[50, 50, 50]} speed={0.05} opacity={0.3} radius={150} height={20} />\n      <AnimatedCloud position={[1250, 750, -700]} scale={[35, 35, 35]} speed={0.04} opacity={0.25} radius={180} height={30} />\n      <AnimatedCloud position={[780, 200, -500]} scale={[45, 45, 45]} speed={0.06} opacity={0.3} radius={220} height={40} />\n      <AnimatedCloud position={[-500, 1220, -500]} scale={[32, 32, 32]} speed={0.03} opacity={0.2} radius={160} height={25} />\n      <AnimatedCloud position={[200, 10, -300]} scale={[38, 38, 38]} speed={0.05} opacity={0.25} radius={190} height={35} />\n\n      <AnimatedCloud position={[-400, 180, -800]} scale={[28, 28, 28]} speed={0.08} opacity={0.2} radius={140} height={15} />\n      <AnimatedCloud position={[350, 200, -650]} scale={[33, 33, 33]} speed={0.07} opacity={0.22} radius={170} height={20} />\n      <AnimatedCloud position={[-250, 260, -800]} scale={[25, 25, 25]} speed={0.09} opacity={0.18} radius={130} height={10} />\n      <AnimatedCloud position={[450, 240, -700]} scale={[33, 33, 33]} speed={0.06} opacity={0.21} radius={175} height={75} />\n\n      <group position={[-900, 590, -800]} scale={[29, 29, 29]}>     \n        <Cloud position={[0, 0, 0]} speed={0.07} opacity={0.19} />\n      </group>\n\n      <group position={[900, 350, -900]} scale={[42, 42, 42]}>     \n        <Cloud position={[0, 0, 0]} speed={0.02} opacity={0.32} />\n      </group>\n\n      <AnimatedCloud position={[800, 120, -100]} scale={[38, 38, 38]} speed={0.03} opacity={0.28} radius={185} height={30} />\n\n      <AnimatedCloud position={[700, 280, -200]} scale={[36, 36, 36]} speed={0.04} opacity={0.24} radius={165} height={20} />\n      <AnimatedCloud position={[-600, 260, -600]} scale={[40, 40, 40]} speed={0.05} opacity={0.26} radius={195} height={25} />\n      <AnimatedCloud position={[100, 400, -1200]} scale={[48, 48, 48]} speed={0.01} opacity={0.35} radius={230} height={45} />\n      <AnimatedCloud position={[-400, 380, -1100]} scale={[44, 44, 44]} speed={0.02} opacity={0.29} radius={210} height={35} />\n      <AnimatedCloud position={[500, 340, -800]} scale={[39, 39, 39]} speed={0.03} opacity={0.27} radius={200} height={30} />\n    </>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/mountain-scene/night-clouds.tsx"
    },
    {
      "path": "registry/new-york/blocks/MountainScene/HorizonBackground.tsx",
      "content": "import * as THREE from 'three';\nimport { useMemo } from 'react';\n\ninterface HorizonBackgroundProps {\n  variant?: 'sunset' | 'sunrise' | 'night';\n  intensity?: number;\n  horizonBand?: number;\n  radius?: number;\n}\n\nexport function HorizonBackground({ variant = 'sunrise', intensity = 1, horizonBand = 0.35, radius = 12000 }: HorizonBackgroundProps) {\n  const colors = useMemo(() => {\n    if (variant === 'night') {\n      return {\n        top: new THREE.Color('#070b20'),\n        mid: new THREE.Color('#0b1748'),\n        warm1: new THREE.Color('#0b1748'),\n        warm2: new THREE.Color('#0b1748'),\n      };\n    }\n    if (variant === 'sunrise') {\n      return {\n        top: new THREE.Color('#0b1748'),\n        mid: new THREE.Color('#284b8f'),\n        warm1: new THREE.Color('#ffb347'),\n        warm2: new THREE.Color('#ff6a00'),\n      };\n    }\n    return {\n      top: new THREE.Color('#0a1438'),\n      mid: new THREE.Color('#345ea9'),\n      warm1: new THREE.Color('#ffc04d'),\n      warm2: new THREE.Color('#ff5a1f'),\n    };\n  }, [variant]);\n\n  const uniforms = useMemo(() => ({\n    topColor: { value: colors.top },\n    midColor: { value: colors.mid },\n    warm1Color: { value: colors.warm1 },\n    warm2Color: { value: colors.warm2 },\n    horizonBand: { value: horizonBand },\n    intensity: { value: intensity },\n  }), [colors, horizonBand, intensity]);\n\n  return (\n    <mesh scale={1}>\n      <sphereGeometry args={[radius, 64, 64]} />\n      <shaderMaterial\n        uniforms={uniforms}\n        vertexShader={`\n          varying vec2 vUv;\n          void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n          }\n        `}\n        fragmentShader={`\n          precision highp float;\n          varying vec2 vUv;\n          uniform vec3 topColor;\n          uniform vec3 midColor;\n          uniform vec3 warm1Color;\n          uniform vec3 warm2Color;\n          uniform float horizonBand;\n          uniform float intensity;\n\n          void main() {\n            float y = vUv.y;\n\n            float h = horizonBand;        // ~0.5 around the visual horizon\n            float warmW = 0.06;           // thickness of golden band\n            float blendUp = 0.16;         // fade distance into blue\n\n            vec3 color = warm2Color;\n            float tWarm = smoothstep(h - warmW, h - warmW * 0.2, y);\n            color = mix(warm2Color, warm1Color, tWarm);\n\n            float tMid = smoothstep(h - warmW * 0.2, h + blendUp, y);\n            color = mix(color, midColor, tMid);\n\n            float tTop = smoothstep(h + blendUp, 1.0, y);\n            color = mix(color, topColor, tTop);\n\n            float glow = 1.0 - smoothstep(h, h + 0.18, y);\n            color += warm1Color * (0.12 * glow * intensity);\n\n            gl_FragColor = vec4(color, 1.0);\n          }\n        `}\n        side={THREE.BackSide}\n        depthWrite={false}\n      />\n    </mesh>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/mountain-scene/horizon-background.tsx"
    },
    {
      "path": "registry/new-york/blocks/MountainScene/examples.tsx",
      "content": "import { Canvas } from '@react-three/fiber';\nimport { OrbitControls } from '@react-three/drei';\nimport { Ocean, StarField, AnimatedCloud, DynamicLighting } from './index';\n\n// Example: Custom mountain scene with user controls\nexport function CustomMountainScene() {\n  return (\n    <div style={{ width: '100vw', height: '100vh', background: '#000011' }}>\n      <Canvas \n        shadows \n        camera={{ position: [0, 50, 200], fov: 75 }}\n        gl={{ antialias: true }}\n      >\n        {/* Basic lighting */}\n        <ambientLight intensity={0.1} />\n        <DynamicLighting />\n        \n        {/* Ocean with day/night transition */}\n        <Ocean transitionProgress={0.8} />\n        \n        {/* Star field for night sky */}\n        <StarField />\n        \n        {/* Custom cloud formations */}\n        <AnimatedCloud \n          position={[-100, 100, -200]} \n          scale={[30, 30, 30]} \n          speed={0.03} \n          opacity={0.6}\n          radius={150}\n        />\n        \n        <AnimatedCloud \n          position={[150, 120, -300]} \n          scale={[25, 25, 25]} \n          speed={0.02} \n          opacity={0.4}\n          radius={180}\n          height={30}\n        />\n        \n        <AnimatedCloud \n          position={[0, 80, -400]} \n          scale={[35, 35, 35]} \n          speed={0.04} \n          opacity={0.5}\n          radius={200}\n        />\n        \n        {/* Camera controls for interaction */}\n        <OrbitControls \n          enablePan={true}\n          enableZoom={true}\n          enableRotate={true}\n          minDistance={50}\n          maxDistance={1000}\n        />\n      </Canvas>\n    </div>\n  );\n}\n\n// Example: Minimal scene with just ocean and stars\nexport function MinimalScene() {\n  return (\n    <div style={{ width: '800px', height: '600px' }}>\n      <Canvas camera={{ position: [0, 0, 100] }}>\n        <ambientLight intensity={0.05} />\n        <Ocean transitionProgress={1.0} />\n        <StarField />\n      </Canvas>\n    </div>\n  );\n}\n\n// Example: Day scene with clouds\nexport function DayScene() {\n  return (\n    <div style={{ width: '100%', height: '500px' }}>\n      <Canvas camera={{ position: [0, 50, 300] }}>\n        <ambientLight intensity={0.3} />\n        <directionalLight position={[100, 100, 50]} intensity={1} />\n        \n        {/* Day ocean */}\n        <Ocean transitionProgress={0} />\n        \n        {/* Day clouds with higher opacity */}\n        <AnimatedCloud \n          position={[-200, 150, -400]} \n          scale={[40, 40, 40]} \n          speed={0.05} \n          opacity={0.9}\n          radius={250}\n        />\n        \n        <AnimatedCloud \n          position={[300, 180, -500]} \n          scale={[35, 35, 35]} \n          speed={0.03} \n          opacity={0.8}\n          radius={300}\n          height={40}\n        />\n      </Canvas>\n    </div>\n  );\n}",
      "type": "registry:component",
      "target": "components/mountain-scene/examples.tsx"
    },
    {
      "path": "registry/new-york/blocks/MountainScene/index.ts",
      "content": "export { Ocean } from './Ocean';\nexport { MountainLake } from './MountainLake';\nexport { DynamicLighting } from './DynamicLighting';\nexport { AnimatedCloud } from './AnimatedCloud';\nexport { StarField } from './StarField';\nexport { NightClouds } from './NightClouds';\nexport { default as MountainScene } from './MountainScene';\nexport { HorizonBackground } from './HorizonBackground';\n",
      "type": "registry:component",
      "target": "components/mountain-scene/index.ts"
    }
  ]
}