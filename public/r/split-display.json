{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "split-display",
  "type": "registry:block",
  "title": "Split Display",
  "description": "A 3D video display component with rotating panels using Three.js and React Three Fiber.",
  "dependencies": [
    "@react-three/fiber",
    "@react-three/drei",
    "three"
  ],
  "files": [
    {
      "path": "registry/new-york/blocks/split-display/split-display.tsx",
      "content": "'use client';\n\nimport { Canvas } from '@react-three/fiber'\nimport type { CSSProperties, HTMLAttributes } from 'react'\nimport { useEffect, useRef, useState } from 'react'\nimport { useFrame, useThree } from '@react-three/fiber'\nimport * as THREE from 'three'\nimport { shaderMaterial } from '@react-three/drei'\nimport { extend } from '@react-three/fiber'\n\n// Custom Shader Material for UV cropping\nconst VideoCropMaterial = shaderMaterial(\n  {\n    map: null,\n    uvOffset: new THREE.Vector2(0, 0),\n    uvScale: new THREE.Vector2(1, 1),\n  },\n  // vertex shader\n  `\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);\n    }\n  `,\n  // fragment shader\n  `\n    uniform sampler2D map;\n    uniform vec2 uvOffset;\n    uniform vec2 uvScale;\n    varying vec2 vUv;\n    void main() {\n      vec2 croppedUv = vUv * uvScale + uvOffset;\n      gl_FragColor = texture2D(map, croppedUv);\n    }\n  `\n)\n\nextend({ VideoCropMaterial })\n\ndeclare module 'react' {\n  interface IntrinsicElements {\n    videoCropMaterial: {\n      map?: THREE.Texture\n      uvOffset?: [number, number]\n      uvScale?: [number, number]\n    }\n  }\n}\n\ndeclare module 'react/jsx-runtime' {\n  interface IntrinsicElements {\n    videoCropMaterial: {\n      map?: THREE.Texture\n      uvOffset?: [number, number]\n      uvScale?: [number, number]\n    }\n  }\n}\n\ndeclare module 'react/jsx-dev-runtime' {\n  interface IntrinsicElements {\n    videoCropMaterial: {\n      map?: THREE.Texture\n      uvOffset?: [number, number]\n      uvScale?: [number, number]\n    }\n  }\n}\n\n// Panel types and constants\nexport type Panel = {\n  position: [number, number, number]\n  rotation: [number, number, number]\n  size: [number, number]\n}\n\nconst panels: Panel[] = [\n  { position: [-1.6, 2.5, -0.2], rotation: [0, -0.25, 0], size: [2, 2.5] },\n  { position: [1.1, 2.5, 1.0], rotation: [0, 0.25, -0.1], size: [2, 2.8] },\n  { position: [0, 0, 0.5], rotation: [0, 0, 0], size: [2.3, 4] },\n  { position: [-0.9, -2.5, -0.2], rotation: [0, -0.2, 0.06], size: [1.7, 2.8] },\n  { position: [0.9, -2.5, -0.2], rotation: [0, 0.2, -0.12], size: [1.8, 2.6] },\n]\n\nfunction getPanelsBoundingBox(panels: Panel[]) {\n  let minX = Infinity,\n    maxX = -Infinity,\n    minY = Infinity,\n    maxY = -Infinity\n  panels.forEach(({ position, size }) => {\n    const [x, y] = position\n    const [w, h] = size\n    minX = Math.min(minX, x - w / 2)\n    maxX = Math.max(maxX, x + w / 2)\n    minY = Math.min(minY, y - h / 2)\n    maxY = Math.max(maxY, y + h / 2)\n  })\n  return { minX, maxX, minY, maxY, width: maxX - minX, height: maxY - minY }\n}\n\n// Video Panel Component\nfunction VideoPanel({\n  video,\n  position,\n  rotation,\n  size,\n  uvOffset,\n  uvScale,\n  isCenter = false,\n  showFrame = true,\n  frameColor = '#111111',\n  framePadding = 0.06,\n  framePaddingCenter = 0.1,\n}: {\n  video: HTMLVideoElement | null\n  position: [number, number, number]\n  rotation: [number, number, number]\n  size: [number, number]\n  uvOffset: [number, number]\n  uvScale: [number, number]\n  isCenter?: boolean\n  showFrame?: boolean\n  frameColor?: string\n  framePadding?: number\n  framePaddingCenter?: number\n}) {\n  const [texture, setTexture] = useState<THREE.VideoTexture | null>(null)\n\n  useEffect(() => {\n    if (!video) return\n    const videoTexture = new THREE.VideoTexture(video)\n    videoTexture.minFilter = THREE.LinearFilter\n    videoTexture.magFilter = THREE.LinearFilter\n    videoTexture.format = THREE.RGBAFormat\n    videoTexture.flipY = true\n    videoTexture.colorSpace = THREE.SRGBColorSpace\n    setTexture(videoTexture)\n    return () => videoTexture.dispose()\n  }, [video])\n\n  useFrame(() => {\n    if (texture && video && video.readyState >= video.HAVE_CURRENT_DATA) {\n      texture.needsUpdate = true\n    }\n  })\n\n  if (!texture) return null\n\n  return (\n    <group position={position} rotation={rotation}>\n      {showFrame && (\n        <mesh>\n          <planeGeometry args={[size[0] + (isCenter ? framePaddingCenter : framePadding), size[1] + (isCenter ? framePaddingCenter : framePadding)]} />\n          <meshBasicMaterial color={frameColor} />\n        </mesh>\n      )}\n      <mesh position={[0, 0, 0.01]}>\n        <planeGeometry args={size} />\n        {/* @ts-expect-error */}\n        <videoCropMaterial map={texture} uvOffset={uvOffset} uvScale={uvScale} />\n      </mesh>\n    </group>\n  )\n}\n\n// Video Panel Group Component\nfunction VideoPanelGroup({\n  video,\n  panels,\n  showFrame = true,\n  frameColor = '#111111',\n  framePadding = 0.06,\n  framePaddingCenter = 0.1,\n}: {\n  video: HTMLVideoElement | null\n  panels: Panel[]\n  showFrame?: boolean\n  frameColor?: string\n  framePadding?: number\n  framePaddingCenter?: number\n}) {\n  const bbox = getPanelsBoundingBox(panels)\n\n  return (\n    <>\n      {panels.map((panel, i) => {\n        const [x, y] = panel.position\n        const [w, h] = panel.size\n        const u0 = (x - w / 2 - bbox.minX) / bbox.width\n        const u1 = (x + w / 2 - bbox.minX) / bbox.width\n        const v0 = (y - h / 2 - bbox.minY) / bbox.height\n        const v1 = (y + h / 2 - bbox.minY) / bbox.height\n        const uvOffset: [number, number] = [u0, v0]\n        const uvScale: [number, number] = [u1 - u0, v1 - v0]\n\n        return (\n          <VideoPanel\n            key={i}\n            video={video}\n            position={panel.position}\n            rotation={panel.rotation}\n            size={panel.size}\n            uvOffset={uvOffset}\n            uvScale={uvScale}\n            isCenter={i === 2}\n            showFrame={showFrame}\n            frameColor={frameColor}\n            framePadding={framePadding}\n            framePaddingCenter={framePaddingCenter}\n          />\n        )\n      })}\n    </>\n  )\n}\n\n// Mouse Rotate Group Component\nfunction MouseRotateGroup({ children }: { children: React.ReactNode }) {\n  const group = useRef<THREE.Group>(null)\n  const target = useRef({ x: 0, y: 0 })\n\n  useEffect(() => {\n    const onMove = (e: MouseEvent) => {\n      target.current.y = (e.clientX / window.innerWidth) * 2 - 1\n      target.current.x = (e.clientY / window.innerHeight) * 2 - 1\n      target.current.y *= 0.5\n      target.current.x *= 0.3\n    }\n    window.addEventListener('mousemove', onMove)\n    return () => window.removeEventListener('mousemove', onMove)\n  }, [])\n\n  useFrame(() => {\n    if (group.current) {\n      group.current.rotation.y += (target.current.y - group.current.rotation.y) * 0.08\n      group.current.rotation.x += (target.current.x - group.current.rotation.x) * 0.08\n    }\n  })\n\n  return <group ref={group}>{children}</group>\n}\n\n// Scene Background Component\nfunction SceneBackground({ color }: { color?: string }) {\n  const { scene } = useThree()\n  useEffect(() => {\n    scene.background = color ? new THREE.Color(color) : null\n  }, [color, scene])\n  return null\n}\n\n// Video Element Hook\nfunction useVideoElement(videoUrl: string) {\n  const [video, setVideo] = useState<HTMLVideoElement | null>(null)\n  const [isPlaying, setIsPlaying] = useState(false)\n\n  useEffect(() => {\n    if (!videoUrl) return\n    const videoElement = document.createElement('video')\n    videoElement.src = videoUrl\n    videoElement.crossOrigin = 'anonymous'\n    videoElement.loop = true\n    videoElement.muted = true\n    videoElement.playsInline = true\n    videoElement.preload = 'auto'\n    videoElement.style.position = 'absolute'\n    videoElement.style.width = '1px'\n    videoElement.style.height = '1px'\n    videoElement.style.top = '-9999px'\n    videoElement.style.left = '-9999px'\n    document.body.appendChild(videoElement)\n\n    const handleCanPlay = () => {\n      videoElement.play().then(() => setIsPlaying(true)).catch(() => {})\n    }\n\n    videoElement.addEventListener('canplay', handleCanPlay)\n    videoElement.addEventListener('loadeddata', () => setVideo(videoElement))\n    videoElement.addEventListener('play', () => setIsPlaying(true))\n    videoElement.addEventListener('pause', () => setIsPlaying(false))\n\n    videoElement.load()\n\n    return () => {\n      videoElement.removeEventListener('canplay', handleCanPlay)\n      if (document.body.contains(videoElement)) {\n        document.body.removeChild(videoElement)\n      }\n    }\n  }, [videoUrl])\n\n  useEffect(() => {\n    if (video && !isPlaying) {\n      const tryPlay = () => {\n        video\n          .play()\n          .then(() => {\n            setIsPlaying(true)\n            document.removeEventListener('click', tryPlay)\n            document.removeEventListener('touchstart', tryPlay)\n          })\n          .catch(() => {})\n      }\n      document.addEventListener('click', tryPlay)\n      document.addEventListener('touchstart', tryPlay)\n      return () => {\n        document.removeEventListener('click', tryPlay)\n        document.removeEventListener('touchstart', tryPlay)\n      }\n    }\n  }, [video, isPlaying])\n\n  return video\n}\n\n// Main Split Display Component\nexport type SplitDisplayProps = {\n  videoUrl?: string\n  showDebug?: boolean\n  showLoadingOverlay?: boolean\n  loadingOverlayClassName?: string\n  debugPanelClassName?: string\n  showFrame?: boolean\n  frameColor?: string\n  framePadding?: number\n  framePaddingCenter?: number\n  backgroundColor?: string\n  canvasAlpha?: boolean\n  sceneBackgroundColor?: string\n  containerClassName?: string\n  containerStyle?: CSSProperties\n  containerProps?: HTMLAttributes<HTMLDivElement>\n}\n\nexport function SplitDisplay({\n  videoUrl = '',\n  showDebug = false,\n  showLoadingOverlay = true,\n  loadingOverlayClassName = 'absolute inset-0 flex items-center justify-center bg-black bg-opacity-50 text-white',\n  debugPanelClassName = 'absolute top-4 right-4 w-fit bg-black bg-opacity-70 text-white p-3 rounded-lg text-sm',\n  showFrame = true,\n  frameColor = '#111111',\n  framePadding = 0.06,\n  framePaddingCenter = 0.1,\n  backgroundColor = 'black',\n  canvasAlpha = false,\n  sceneBackgroundColor,\n  containerClassName = '',\n  containerStyle,\n  containerProps = {},\n}: SplitDisplayProps) {\n  const video = useVideoElement(videoUrl)\n\n  return (\n    <div\n      {...containerProps}\n      className={[\n        'w-full h-screen',\n        containerClassName,\n        containerProps.className || '',\n      ]\n        .filter(Boolean)\n        .join(' ')}\n      style={{\n        position: 'relative',\n        background: backgroundColor,\n        ...(containerProps.style || {}),\n        ...(containerStyle || {}),\n      }}\n    >\n      <Canvas camera={{ position: [0, 0, 16], fov: 45 }} gl={{ antialias: true, alpha: canvasAlpha }}>\n        <SceneBackground color={sceneBackgroundColor} />\n        <ambientLight intensity={1.5} />\n        <pointLight position={[0, 0, 8]} intensity={0.3} color=\"#8b5cf6\" />\n        <MouseRotateGroup>\n          <VideoPanelGroup\n            video={video}\n            panels={panels}\n            showFrame={showFrame}\n            frameColor={frameColor}\n            framePadding={framePadding}\n            framePaddingCenter={framePaddingCenter}\n          />\n        </MouseRotateGroup>\n      </Canvas>\n      {!video && showLoadingOverlay && (\n        <div className={loadingOverlayClassName}>Loading video...</div>\n      )}\n      {showDebug && video && (\n        <div className={debugPanelClassName}>\n          <div>Status: {video.paused ? 'Paused' : 'Playing'}</div>\n          <div>Ready State: {video.readyState}/4</div>\n          <div>Current Time: {video.currentTime.toFixed(1)}s</div>\n          <div>Duration: {video.duration ? `${video.duration.toFixed(1)}s` : 'Unknown'}</div>\n        </div>\n      )}\n    </div>\n  )\n}\n\nexport default SplitDisplay",
      "type": "registry:component",
      "target": "components/split-display.tsx"
    }
  ]
}